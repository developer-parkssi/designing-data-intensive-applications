# 04 부호화와 발전
- 대규모 애플리케이션에서 코드 변경은 대개 즉시 반영할 수 없다
- 예전 버전의 코드와 새로운 버전의 코드, 이전의 데이터 타입과 새로운 데이터 타입이 어쩌면 모든 시스템에 동시에 공존할 수 있다
- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다
- 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다
- 상위 호환성은 예전 버전의 코드가 새 버전의 코드에 의해 추가된 것을 무시할 수 있어야 하므로 다루기 더 어렵다

## 데이터 부호화 형식
- 프로그램은 보통 (최소한) 두 가지 형태로 표현된 데이터를 사용해 동작
- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table) , 트리(tree) 등으로 데이터가 유지
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(예를 들어 JSON 문서)의 형태로 부호화
- 인메모리 표현에서 바이트열로의 전환을 **부호화** (**직렬화** 나 **마살링** 이라고도 함)라고 하며, 그 반대를 **복호화** (**파싱**，**역직렬화**，**언마살링**이라고도 함)

## 언어별 형식
- 많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장   
ex) 자바(java.io.Serializable), 루비(Marsha), 파이썬(pickle)

- 기존 내장 부호화 기능들의 단점
  1. 부호화는 보통 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다. 이런 부호화로 데이터를 저장하고 전송하는 경우 매우 오랜 시간이 될지도 모를 기간 동안 현재 프로그래밍 언어로만 코드를 작성해야 할 뿐 아니라 다른 시스템(다른 언어를 사용할 수도 있음)과 통합하는데 방해가 된다.
  2. 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다. 이것은 종종 보안 문제의 원인이 된다. 공격자가 임의의 바이트열을 복호화할 수 있는 애플리케이션을 얻을 수 있으면 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행하는 것과 같은 끔찍한 일이 발생할 수 있다
  3. 데이터 버전 관리는 보통 부호화 라이브러리에서는 나중에 생각하게 된다. 데이터를 빠르고 쉽게 부호화하기 위해 상위, 하위 호환성의 불편한 문제가 등한시되곤 한다.
  4. 효율성(부호화나 복호화에 소요되는 CPU 시간과 부호화된 구조체의 크기)도 종종 나중에 생각하게 된다. 예를 들어 자바의 내장 직렬화 성능이 좋지 않고 비대해지는 부호화로 유명하다

## JSON과 XML, 이진 변형
- JSON, XML, CSV는 텍스트 형식이라서 사람이 있을 수 있지만 피상적인 문법적 문제 외에도 여러가지 존재
  1. 수(number)의 부호화에는 많은 애매함
  2. 큰 수를 다룰 때 문제
  3. 이진 문자열(문자 부호화가 없는 바이트열)을 지원 X
  4. 스키마 언어는 상당히 강력하지만 익히고 구현하기가 상당히 난해. XML/JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 가능성
  5. CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이션이 해야한다

## 이진 부호화
- 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜하다
- JSON은 XML보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간을 사용

![img.png](img.png)

- 메시지팩은 JSON용 이진 부호화 형식

![img2.png](img2.png)

- 이진 부호화는 길이가 66바이트로 텍스트 JSON 부호화로 얻은 81바이트(공백은 제거)보다 약간 작다
- 이같은 작은 공간의 절약(과 어쩌면 파싱 속도의 향상)이 사람의 가독성을 해칠 만큼 가치가 있는지는 확실치 X

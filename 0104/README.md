# 04 부호화와 발전
- 대규모 애플리케이션에서 코드 변경은 대개 즉시 반영할 수 없다
- 예전 버전의 코드와 새로운 버전의 코드, 이전의 데이터 타입과 새로운 데이터 타입이 어쩌면 모든 시스템에 동시에 공존할 수 있다
- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다
- 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다
- 상위 호환성은 예전 버전의 코드가 새 버전의 코드에 의해 추가된 것을 무시할 수 있어야 하므로 다루기 더 어렵다

## 데이터 부호화 형식
- 프로그램은 보통 (최소한) 두 가지 형태로 표현된 데이터를 사용해 동작
- 메모리에 객체(object), 구조체(struct), 목록(list), 배열(array), 해시 테이블(hash table) , 트리(tree) 등으로 데이터가 유지
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열(예를 들어 JSON 문서)의 형태로 부호화
- 인메모리 표현에서 바이트열로의 전환을 **부호화** (**직렬화** 나 **마살링** 이라고도 함)라고 하며, 그 반대를 **복호화** (**파싱**，**역직렬화**，**언마살링**이라고도 함)

## 언어별 형식
- 많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장   
ex) 자바(java.io.Serializable), 루비(Marsha), 파이썬(pickle)

- 기존 내장 부호화 기능들의 단점
  1. 부호화는 보통 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어렵다. 이런 부호화로 데이터를 저장하고 전송하는 경우 매우 오랜 시간이 될지도 모를 기간 동안 현재 프로그래밍 언어로만 코드를 작성해야 할 뿐 아니라 다른 시스템(다른 언어를 사용할 수도 있음)과 통합하는데 방해가 된다.
  2. 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다. 이것은 종종 보안 문제의 원인이 된다. 공격자가 임의의 바이트열을 복호화할 수 있는 애플리케이션을 얻을 수 있으면 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행하는 것과 같은 끔찍한 일이 발생할 수 있다
  3. 데이터 버전 관리는 보통 부호화 라이브러리에서는 나중에 생각하게 된다. 데이터를 빠르고 쉽게 부호화하기 위해 상위, 하위 호환성의 불편한 문제가 등한시되곤 한다.
  4. 효율성(부호화나 복호화에 소요되는 CPU 시간과 부호화된 구조체의 크기)도 종종 나중에 생각하게 된다. 예를 들어 자바의 내장 직렬화 성능이 좋지 않고 비대해지는 부호화로 유명하다

## JSON과 XML, 이진 변형
- JSON, XML, CSV는 텍스트 형식이라서 사람이 있을 수 있지만 피상적인 문법적 문제 외에도 여러가지 존재
  1. 수(number)의 부호화에는 많은 애매함
  2. 큰 수를 다룰 때 문제
  3. 이진 문자열(문자 부호화가 없는 바이트열)을 지원 X
  4. 스키마 언어는 상당히 강력하지만 익히고 구현하기가 상당히 난해. XML/JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 가능성
  5. CSV는 스키마가 없으므로 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이션이 해야한다

## 이진 부호화
- 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜하다
- JSON은 XML보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간을 사용

![img.png](img.png)

- 메시지팩은 JSON용 이진 부호화 형식

![img2.png](img2.png)

- 이진 부호화는 길이가 66바이트로 텍스트 JSON 부호화로 얻은 81바이트(공백은 제거)보다 약간 작다
- 이같은 작은 공간의 절약(과 어쩌면 파싱 속도의 향상)이 사람의 가독성을 해칠 만큼 가치가 있는지는 확실치 X

### 스리프트와 프로토콜 버퍼

- 아파치 스리프트와 프로토콜 버퍼는 같은 원리를 기반으로 한 이진 부호화 라이브러리
- 스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요
- 스리프트 인터페이스 정의 언어로 스키마 기술

![img3.png](img3.png)

- 프로토콜 버퍼로 정의한 동등한 스키마는 스리프트 스키마와 매우 비슷

![img4.png](img4.png)

- 스리프트는 바이너리 프로토콜과 컴팩트 프로토콜이라는 두가지 다른 이진 부호화 형식 존재

![img5.png](img5.png)

- 마찬가지로 각 필드에는 (타입이 문자열，정수，목록 등인지 나타내기 위해) 타입 주석이 있고 필요한 경우 길이(문자열의 길이，목록의 항목 개수) 표시가 있다
- 큰 차이점으로 필드 이름 X. 대신 부호화된 데이터는 숫자(1, 2, 3)과 같은 **필드 태그(field tag)** 를 포함
  - 이 숫자는 스키마 정의에 나타난 숫자
- 컴팩트 프로토콜 부호화는 의미상으로는 바이너리 프로토콜과 같지만 동일한 정보를 단지 34바이트로 줄여 부호화
  - 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화
  - 각 바이트의 상위 비트는 앞으로 더 많은 바이트가 있는지를 나타내는 데 사용
  - 더 큰 숫자는 더 많은 바이트를 사용

![img6.png](img6.png)

- 프로토콜 버퍼는 그림 4-4 처럼 동일한 데이터를 부호화
- 비트를 줄여 저장하는 처리 방식이 약간 다르지만 스리프트의 컴팩트프로토콜과 매우 비슷
- 프로토콜 버퍼는 같은 데이터를 33바이트로 만든다

![img7.png](img7.png)

- required를 사용하면 필드가 설정되지 않은 경우를 실행 시에 확인 가능. 이 기능은 버그 잡을 때 유용

### 필드 태그와 스키마 발전

- 부호화된 레코드는 부호화된 필드의 연결일 뿐
- 각 필드는 태그 숫자(예제 스키마의 숫자 1,2,3)로 식별하고 데이터타입(예를 들어 문자열, 정수)을 주석으로 단다
- 필드값을 설정하지 않은 경우는 단순히 부호화 레코드에서 생략
- 부호화된 데이터는 필드 이름을 전혀 참조하지 않기 때문에 스키마에서 필드 이름은 변경 가능
- 필드 태그는 기존의 모든 부호화된 데이터를 인식 불가능하게 만들 수 있기 때문에 변경 X
- 필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드를 추가 가능
- 예전 코드에서 새로운 코드로 기록한 데이터를 읽으려는 경우에는 해당 필드 간단히 무시 가능
- 데이터타입 주석은 파서가 몇 바이트를 건너될 수 있는지 알려준다
  - 상위 호환성 유지 가능
- 각 필드에 고유한 태그 번호가 있는 동안에는 태그 번호가 계속 같은 의미를 가지고 있기 때문에 새로운 코드가 예전 데이터를 항상 읽기 가능
- 사소한 문제 하나로 새로운 필드를 추가한 경우 이 필드를 required 선언 X
- 하위 호환성을 유지하려면 스키마의 초기 배포 후에 추가되는 모든 필드는 optional로 하거나 기본값
- 필드를 삭제하는 방법은 필드를 추가할 때 하위 호환성과 상위 호환성 문제를 해결하는 방식과 반대로
- 즉 optional 필드만 삭제할 수 있고, 같은 태그 번호는 절대 다시 사용 X

### 데이터타입과 스키마 발전

- 필드의 데이터타입을 변경하는 건 가능하지만 값이 정확하지 않거나 잘릴 위험이 있다
- 프로토콜 버퍼가 가진 흥미로운 기능 하나로 프로토콜 버퍼에는 목록이나 배열 데이터타입이 없지만 repeated 표시자 존재
- repeated 필드의 부호화는 레코드에 단순히 동일한 필드 태그가 여러번 나타난다
- 스리프트에는 전용 목록 데이터타입
- 목록 데이터타입은 프로토콜 버퍼와는 다르게 단일 값에서 다중 값으로의 변경을 허용하지 않지만 중첩된 목록을 지원한다는 장점

### 아브로

- 스리프트가 하둡의 사용 사례에 적합하지 않아 2009년 하둡의 하위 프로젝트로 시작
- 부호화할 데이터 구조를 지정하기 위해 스키마를 사용
- 두 개의 스키마 언어 존재
  1. 사람이 편집할 수 있는 아브로 IDL(Avro IDL)
  2. 기계가 더 쉽게 읽을 수 있는 JSON 기반 언어

![img8.png](img8.png)

![img9.png](img9.png)

- 스키마에 태그 번호가 없다

![img10.png](img10.png)

- 바이트열을 살펴보면 필드나 데이터타입을 식별하기 위한 정보가 없음
- 문자열은 길이 다음에 UTF-8 바이트가 이어지지만 문자열임을 알려주는 정보가 부호화된 데이터에는 없다
- 정수는 가변 길이 부호화를 사용해서 부호화
- 아브로를 이용해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야 한다
- 데이터를 읽는 코드가 데이터를 기록한 코드와 **정확히 같은 스키마** 를 사용하는 경우에만 이진 데이터를 올바르게 복호화

** 쓰기 스키마와 읽기 스키마 **

- 어떤 데이터를 아브로로 부호화하길 원한다면 알고 있는 스키마 버전을 사용해 데이터를 부호화, **쓰기 스키마(writer’s schema)**
- 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화하길 기대, **읽기 스키마(reader's schema)**
- 복호화 코드는 애플리케이션을 빌드하는 동안 스키마로부터 생성
- 아브로의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 단지 호환 가능하면 된다는 것
- 복호화(읽기)할 때 아브로 라이브러리는 쓰기 스키마와 읽기 스키마를 함께 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소
- 쓰기 스키마와 읽기 스키마는 필드 순서가 달라도 문제 X
  - 스키마 해석(schema resolution) 에서는 이름으로 필드를 일치시키기 때문
- 데이터를 읽는 코드가 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드를 만나면 이 필드는 무시
- 데이터를 읽는 코드가 기대하는 어떤 필드가 쓰기 스키마에는 포함돼 있지 않은 경우에는 읽기 스키마에 선언된 기본값

![img11.png](img11.png)

**스키마 발전 규칙**

- 아브로에서 상위 호환성은 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음을 의미
- 하위 호환성은 새로운 버전의 읽기 스키마와 예전 버전의 쓰기 스키마를 가질 수 있음을 의미
- 호환성을 유지하기 위해서는 기본값이 있는 필드만 추가 or 삭제 가능
- 기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기록한 데이터를 읽을 수 없기 때문에 하위 호환성이 깨진다
- 기본값이 없는 필드를 삭제하면 예전 읽기는 새로운 쓰기가 기록한 데이터를 읽을 수 없기 때문에 상위 호환성이 깨진다
- 필드에 널을 허용하려면 **유니온 타입(union type)** 을 사용
  - union { null, long, string } field;   
    field가 수나 문자열 또는 널일 수 있다는 의미 
  - 필드가 유니온 엘리먼트 중 하나인 경우에만 기본값으로 널을 사용 가능
- 아브로는 프로토콜 버퍼，스리프트와 동일한 방식의 optional과 required 표시자를 가지지 않는다
- 아브로는 타입을 변환할 수 있으므로 필드의 데이터타입 변경이 가능
- 필드 이름 변경도 가능하지만 까다롭다
  - 읽기 스키마는 필드 이름의 별칭을 포함 가능
  - 별칭에 예전 쓰기 스키마 필드 이름을 매치 가능
  - 필드 이름 변경은 하위 호환성이 있지만 상위 호환성은 없다는 의미
  - 비슷하게 유니온 타입에 엘리먼트를 추가하는 것은 하위 호환성은 있지만 상위 호환성은 X

**그러면 쓰기 스키마는 무엇인가?**

- 읽기기 특정 데이터를 부호화한 쓰기 스키마를 알 수 있는 방법은 아브로를 사용하는 상황에 따라 다르다.
  1. 많은 레코드가 있는 대용량 파일
  2. 개별적으로 기록된 레코드를 가진 데이터베이스
    - 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에는 스키마 버전 목록을 유지
    - 가져온 쓰기 스키마를 사용해 남은 레코드를 복호화
  3. 네트워크 연결을 통해 레코드 보내기
- 스키마 버전을 사용하는 데이터베이스는 어떤 경우라도 유용

**동적 생성 스키마**

- 프로토콜 버퍼와 스리프트에 비해 아브로 방식은 스키마에 태그 번호가 포함돼 있지 않다는 장점
- 아브로가 **동적 생성** 스키마에 더 친숙하다는 점
- 데이터베이스 스키마가 변경되면 갱신된 데이터베이스 스키마로부터 새로운 아브로 스키마를 생성하고 새로운 아브로 스키마로 데이터를 내보낸다
- 새로운 데이터 파일을 읽는 사람은 레코드 필드가 변경된 사실을 알게 되지만 필드는 이름으로 식별되기 때문에 갱신된 쓰기 스키마는 여전히 이전 읽기 스키마와 매치 가능
- 스리프트나 프로토콜 버퍼를 이런 용도로 사용한다면 필드 태그를 수동으로 할당해야 한다
- 데이터베이스 스키마가 변경될 때마다 관리자는 데이터베이스 칼럼 이름과 필드 태그의 매핑을 수동으로 갱신

**코드 생성과 동적 타입 언어**

- 스리프트와 프로토콜 버퍼는 코드 생성에 의존. 스키마를 정의한 후 선택한 프로그래밍 언어로 스키마를 구현한 코드를 생성 가능
- JS, Ruby, Python 같은 동적 타입 프로그래밍 언어에서는 만족시킬 컴파일 시점의 타입검사기가 없기 때문에 코드를 생성하는 것이 중요 X
- 동적 생성 스키마의 경우 코드 생성은 데이터 가져오는데 불필요한 장애물
- 아브로는 정적 타입 프로그래밍 언어를 위해 코드 생성을 선택적으로 제공. 하지만 코드 생성없이도 사용 가능
- 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 간단히 열어 JSON 파일을 보는 것과 같이 데이터를 볼 수 있다, **자기 기술(self-describing)** 
- 아파치 피그 같은 경우 아브로 파일만 있으면 즉시 열어 분석 가능하고, 스키마를 생각하지 않고도 아브로 형식으로 출력 파일에 파생 데이터를 기록

**스키마의 장점**

- 이진 부호화에는 좋은 속성이 많이 있다
1. 부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 다양한 "이진 JSON" 변형보다 크기가 훨씬 작을 수 있다.
2. 스키마는 유용한 문서화 형식. 복호화를 할 때 스키마가 필요하기 때문에 스키마가 최신 상태인지를 확신 가능(반면 수동으로 관리하는 문서는 실제와 달라지기 쉽다)
3. 스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인 가능
4. 정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드를 생성하는 기능은 유용. 컴파일 시점에 타입 체크를 할 수 있기 때문

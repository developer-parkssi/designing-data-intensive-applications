# 복제

- 데이터 **복제**가 필요한 여러 이유
1. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다
2. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
3. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다

- 복제에서 모든 어려움은 복제된 데이터의 **변경** 처리에 있다
- 노드 간 변경을 복제하기 위한 세 가지 인기 있는 알고리즘
1. 단일 리더(single-leader)
2. 다중 리더(multi-leader)
3. 리더 없는(leaderless)

## 리더와 팔로워

- 데이터베이스의 복사본을 저장하는 각 노드를 **복제 서버(replica)** 라 한다
- 데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다. 이 문제를 위한 일반적인 해결책은    
**리더 기반 복제(leader-based replication)** = **능동(active)** / **수동(passive)** = **마스터(master) 슬레이브(slave)**
- 복제 서버 중 하나를 **리더(leader)** (**마스터**나 **프라이머리(primary)** 라고도 함)로 지정
- 다른 복제 서버는 **팔로워(follower)** (**읽기 복제 서버(read replica)**, **슬레이브**, **2차(secondary)핫 대기(hot standby)**)
- 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 **복제 로그(replication log)** 나 **변경 스트림(change stream)** 의 일부로 팔로워에게 전송
- 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신
- 클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의 가능. 하지만 쓰기는 리더에게만 허용

![img.png](img.png)

### 동기식 대 비동기식 복제

- 복제 시스템의 중요한 세부 사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부

![img2.png](img2.png)

- 그림 5-2 의 예제에서 팔로워 1의 복제는 동기식. 리더는 팔로워 1이 쓰기를 수신했는지 확인해 줄 때까지 기다린다
- 팔로워 2의 복제는 비동기식. 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다
- 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
- 단점은 (팔로워가 죽거나 네트워크 문제나 다른 어떤 이유로 인해) 동기 팔로워가 응답하지 않는다면 쓰기 처리 X
- 리더는 모든 쓰기를 차단(block) 하고 동기 복제 서버가 다시 사용할 수 있을 때까지 대기
- **반동기식**
  - 현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미
  - 적어도 두 노드(리더와 하나의 동기 팔로워)에 데이터의 최신 복사본이 있는 것을 보장
- 리더 기반 복제는 완전히 비동기식으로 구성
- 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실
- 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점
- 비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프 같지만 그럼에도 특히 많은 팔로워가 있거나 지리적으로 분산됐다면 비동기식 복제를 널리 사용

### 새로운 팔로워 설정

- 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?
- 간단히 한 노드에서 다른 노드로 데이터 파일을 복사하는 것만으로는 대개 충분 X. 복사 결과가 유효하지 않을 수 있다
- 팔로워 설정은 대개 중단시간 없이 수행 가능
1. 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다
2. 스냅숏을 새로운 팔로워 노드에 복사
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다

### 노드 중단 처리

- 중단시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지보수에 큰 장점
- 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표

**팔로워 장애: 따라잡기 복구**

- 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관
- 팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 매우 쉽게 복구 가능
- 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아내서 끊긴 데이터 변경 모두 요청 가능

**리더 장애: 장애 복구**

- 리더의 장애는 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요, 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야한다, **장애 복구**
- 자동 장애 복구는 보통 다욤과 같은 단계로 구성
1. 리더가 장애인지 판단한다
2. 새로운 리더를 선택한다
    - 새로운 리더로 가장 적합한 후보는 보통 이전
      리더의 최신 데이터 변경사항을 가진 복제 서버
3. 새로운 리더 사용을 위해 시스템을 재설정한다
